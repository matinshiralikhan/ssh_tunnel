package autodiscovery

import (
	"encoding/json"
	"fmt"
	"strings"
)

// generateSSHTunnelConfig generates SSH tunnel configuration
func (sd *ServerDiscovery) generateSSHTunnelConfig() string {
	if config, exists := sd.configs["ssh"]; exists {
		return fmt.Sprintf(`# SSH Tunnel Configuration
Host tunnel-server
    HostName %s
    Port %s
    User %s
    LocalForward %d 127.0.0.1:%d
    DynamicForward %d
    ServerAliveInterval 60
    ServerAliveCountMax 3
    
# Usage:
# ssh -D %d %s@%s
# Set browser proxy to SOCKS5 127.0.0.1:%d
`,
			sd.info.Host, sd.info.Port, sd.info.User,
			config.Port, config.Port, config.Port,
			config.Port, sd.info.User, sd.info.Host, config.Port)
	}
	return ""
}

// generateV2RayConfig generates V2Ray client configuration
func (sd *ServerDiscovery) generateV2RayConfig() string {
	if config, exists := sd.configs["v2ray"]; exists {
		configMap := map[string]interface{}{
			"inbounds": []map[string]interface{}{
				{
					"tag":      "socks",
					"port":     1080,
					"listen":   "127.0.0.1",
					"protocol": "socks",
					"settings": map[string]interface{}{
						"auth": "noauth",
						"udp":  true,
					},
				},
				{
					"tag":      "http",
					"port":     8080,
					"listen":   "127.0.0.1",
					"protocol": "http",
					"settings": map[string]interface{}{},
				},
			},
			"outbounds": []map[string]interface{}{
				{
					"tag":      "proxy",
					"protocol": "vmess",
					"settings": map[string]interface{}{
						"vnext": []map[string]interface{}{
							{
								"address": sd.info.Host,
								"port":    config.Port,
								"users": []map[string]interface{}{
									{
										"id":       config.Config["uuid"],
										"alterId":  config.Config["alterId"],
										"security": config.Config["security"],
									},
								},
							},
						},
					},
					"streamSettings": map[string]interface{}{
						"network": "tcp",
					},
				},
				{
					"tag":      "direct",
					"protocol": "freedom",
					"settings": map[string]interface{}{},
				},
			},
			"routing": map[string]interface{}{
				"rules": []map[string]interface{}{
					{
						"type":        "field",
						"outboundTag": "direct",
						"domain":      []string{"geosite:private"},
					},
					{
						"type":        "field",
						"outboundTag": "direct",
						"ip":          []string{"geoip:private"},
					},
				},
			},
		}

		jsonData, _ := json.MarshalIndent(configMap, "", "  ")
		return string(jsonData)
	}
	return ""
}

// generateVLESSConfig generates VLESS client configuration
func (sd *ServerDiscovery) generateVLESSConfig() string {
	if config, exists := sd.configs["v2ray"]; exists {
		return fmt.Sprintf(`# VLESS Configuration
vless://%s@%s:%d?type=tcp&security=none&headerType=none#AutoGenerated-VLESS

# For V2rayN/V2rayNG:
# 1. Copy the above URL
# 2. Import via QR code or URL
# 3. Connect and enjoy!

# Manual Configuration:
Server: %s
Port: %d
UUID: %s
Flow: 
Encryption: none
Network: tcp
`,
			config.Config["uuid"], sd.info.Host, config.Port,
			sd.info.Host, config.Port, config.Config["uuid"])
	}
	return ""
}

// generateVMessConfig generates VMess client configuration
func (sd *ServerDiscovery) generateVMessConfig() string {
	if config, exists := sd.configs["v2ray"]; exists {
		vmessConfig := map[string]interface{}{
			"v":    "2",
			"ps":   "AutoGenerated-VMess",
			"add":  sd.info.Host,
			"port": config.Port,
			"id":   config.Config["uuid"],
			"aid":  config.Config["alterId"],
			"scy":  config.Config["security"],
			"net":  "tcp",
			"type": "none",
			"host": "",
			"path": "",
			"tls":  "",
			"sni":  "",
		}

		jsonData, _ := json.Marshal(vmessConfig)

		return fmt.Sprintf(`# VMess Configuration
vmess://%s

# JSON Configuration:
%s

# For V2rayN/V2rayNG:
# 1. Copy the vmess:// URL above
# 2. Import via QR code or URL
# 3. Connect and enjoy!
`,
			string(jsonData), // This should be base64 encoded in practice
			func() string {
				pretty, _ := json.MarshalIndent(vmessConfig, "", "  ")
				return string(pretty)
			}())
	}
	return ""
}

// generateTrojanConfig generates Trojan client configuration
func (sd *ServerDiscovery) generateTrojanConfig() string {
	if config, exists := sd.configs["trojan"]; exists {
		return fmt.Sprintf(`# Trojan Configuration
{
  "run_type": "client",
  "local_addr": "127.0.0.1",
  "local_port": 1080,
  "remote_addr": "%s",
  "remote_port": %d,
  "password": [
    "%s"
  ],
  "log_level": 1,
  "ssl": {
    "verify": false,
    "verify_hostname": false,
    "cert": "",
    "cipher": "ECDHE-RSA-AES128-GCM-SHA256:ECDHE-RSA-CHACHA20-POLY1305:ECDHE-RSA-AES256-GCM-SHA384",
    "cipher_tls13": "TLS_AES_128_GCM_SHA256:TLS_CHACHA20_POLY1305_SHA256:TLS_AES_256_GCM_SHA384",
    "sni": "",
    "alpn": [
      "h2",
      "http/1.1"
    ],
    "reuse_session": true,
    "session_ticket": false,
    "curves": ""
  },
  "tcp": {
    "no_delay": true,
    "keep_alive": true,
    "reuse_port": false,
    "fast_open": false,
    "fast_open_qlen": 20
  }
}

# URL Format:
trojan://%s@%s:%d#AutoGenerated-Trojan

# Usage:
# Set your application to use SOCKS5 proxy: 127.0.0.1:1080
`,
			sd.info.Host, config.Port, config.Config["password"],
			config.Config["password"], sd.info.Host, config.Port)
	}
	return ""
}

// generateWireGuardConfig generates WireGuard client configuration
func (sd *ServerDiscovery) generateWireGuardConfig() string {
	if config, exists := sd.configs["wireguard"]; exists {
		return fmt.Sprintf(`# WireGuard Client Configuration
[Interface]
PrivateKey = <CLIENT_PRIVATE_KEY>
Address = 10.0.0.2/24
DNS = 1.1.1.1, 1.0.0.1

[Peer]
PublicKey = <SERVER_PUBLIC_KEY>
Endpoint = %s:%d
AllowedIPs = 0.0.0.0/0
PersistentKeepalive = 25

# Note: Replace <CLIENT_PRIVATE_KEY> and <SERVER_PUBLIC_KEY> with actual keys
# Generate keys with: wg genkey | tee privatekey | wg pubkey > publickey

# To connect:
# sudo wg-quick up wg0
# sudo wg-quick down wg0
`,
			sd.info.Host, config.Port)
	}
	return ""
}

// generateHysteriaConfig generates Hysteria client configuration
func (sd *ServerDiscovery) generateHysteriaConfig() string {
	if config, exists := sd.configs["hysteria"]; exists {
		return fmt.Sprintf(`# Hysteria Client Configuration
{
  "server": "%s:%d",
  "protocol": "%s",
  "auth_str": "%s",
  "bandwidth": {
    "up": "%s",
    "down": "%s"
  },
  "socks5": {
    "listen": "127.0.0.1:1080"
  },
  "http": {
    "listen": "127.0.0.1:8080"
  },
  "retry": 3,
  "fast_open": true,
  "lazy": false
}

# Usage:
# hysteria -c hysteria.json
# Set SOCKS5 proxy to: 127.0.0.1:1080
# Set HTTP proxy to: 127.0.0.1:8080
`,
			sd.info.Host, config.Port,
			config.Config["protocol"],
			config.Config["auth_str"],
			config.Config["bandwidth"],
			config.Config["bandwidth"])
	}
	return ""
}

// generateHTTPProxyConfig generates HTTP proxy configuration
func (sd *ServerDiscovery) generateHTTPProxyConfig() string {
	if config, exists := sd.configs["http_proxy"]; exists {
		return fmt.Sprintf(`# HTTP Proxy Configuration

# Proxy Settings:
HTTP Proxy: 127.0.0.1:%d

# cURL Usage:
curl --proxy http://127.0.0.1:%d https://example.com

# Environment Variables:
export http_proxy=http://127.0.0.1:%d
export https_proxy=http://127.0.0.1:%d

# PAC File (Proxy Auto-Configuration):
function FindProxyForURL(url, host) {
    return "PROXY 127.0.0.1:%d";
}

# Browser Configuration:
# 1. Go to browser proxy settings
# 2. Set HTTP proxy to: 127.0.0.1:%d
# 3. Use for all protocols
`,
			config.Port, config.Port, config.Port, config.Port, config.Port, config.Port)
	}
	return ""
}

// generateSOCKS5Config generates SOCKS5 proxy configuration
func (sd *ServerDiscovery) generateSOCKS5Config() string {
	if config, exists := sd.configs["socks5_proxy"]; exists {
		return fmt.Sprintf(`# SOCKS5 Proxy Configuration

# Proxy Settings:
SOCKS5 Proxy: 127.0.0.1:%d

# SSH Command:
ssh -D %d %s@%s -p %s

# Browser Configuration:
# 1. Go to browser proxy settings
# 2. Set SOCKS proxy to: 127.0.0.1:%d
# 3. Enable "Proxy DNS when using SOCKS v5"

# Application Usage:
# cURL: curl --socks5 127.0.0.1:%d https://example.com
# Git: git config --global http.proxy socks5://127.0.0.1:%d
`,
			config.Port, config.Port, sd.info.User, sd.info.Host, sd.info.Port,
			config.Port, config.Port, config.Port)
	}
	return ""
}

// generateCombinedConfig generates a combined configuration with all protocols
func (sd *ServerDiscovery) generateCombinedConfig() string {
	var configs []string

	configs = append(configs, "# Combined Multi-Protocol Configuration")
	configs = append(configs, "# Generated automatically by SSH Tunnel Manager")
	configs = append(configs, "")
	configs = append(configs, fmt.Sprintf("version: \"1.0\""))
	configs = append(configs, "")
	configs = append(configs, "# Server Information")
	configs = append(configs, fmt.Sprintf("server:"))
	configs = append(configs, fmt.Sprintf("  host: %s", sd.info.Host))
	configs = append(configs, fmt.Sprintf("  port: %s", sd.info.Port))
	configs = append(configs, fmt.Sprintf("  user: %s", sd.info.User))
	configs = append(configs, fmt.Sprintf("  os: %s", sd.info.OS))
	configs = append(configs, fmt.Sprintf("  architecture: %s", sd.info.Architecture))
	configs = append(configs, "")

	configs = append(configs, "# Available Protocols")
	configs = append(configs, "servers:")

	for protocolType, config := range sd.configs {
		configs = append(configs, fmt.Sprintf("  - name: \"auto-%s\"", protocolType))
		configs = append(configs, fmt.Sprintf("    host: \"%s\"", sd.info.Host))
		configs = append(configs, fmt.Sprintf("    port: \"%d\"", config.Port))
		configs = append(configs, fmt.Sprintf("    transport: \"%s\"", config.Type))
		configs = append(configs, fmt.Sprintf("    proxy: \"socks5\""))
		configs = append(configs, fmt.Sprintf("    local_port: %d", config.Port+1000))
		configs = append(configs, fmt.Sprintf("    enabled: true"))
		configs = append(configs, fmt.Sprintf("    priority: %d", len(configs)))

		if config.ProxyURL != "" {
			configs = append(configs, fmt.Sprintf("    proxy_url: \"%s\"", config.ProxyURL))
		}

		configs = append(configs, "")
	}

	configs = append(configs, "# Quick Start URLs:")
	for protocolType, config := range sd.configs {
		if config.ProxyURL != "" {
			configs = append(configs, fmt.Sprintf("# %s: %s", strings.ToUpper(protocolType), config.ProxyURL))
		}
	}

	return strings.Join(configs, "\n")
}
